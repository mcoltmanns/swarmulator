#version 430

layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

/*
this shader handles the first pass of the grid computation
calculates segment lengths and sets up buffers for the next passes
*/

layout(location=0) uniform vec4 world_size;
layout(location=1) uniform vec4 cell_count;

layout(std430, binding=0) buffer ssbo0 { vec4 positions[]; };
layout(std430, binding=1) buffer ssbo2 { int segment_start[]; }; // total cell count is the length of this - 1
layout(std430, binding=2) buffer ssbo3 { int segment_length[]; };

vec4 cell_size;

// move a point from world to grid space
vec4 world_to_grid(vec4 p) {
    return p + 0.5f * world_size;
}

// get the strided index into the grid (grid cell id) of a given point
// return -1 if that point is not in the grid
// there must be a way to make this simpler!
int cell_index(vec4 p) {
    vec4 p_g = floor(p / cell_size);
    int xpart = int(cell_count.x * cell_count.x * p_g.x);
    int ypart = int(cell_count.y * p_g.y);
    int zpart = int(p_g.z);
    return xpart + ypart + zpart;
    // if any of these are less than 0, return -1
    // so have step return 1 if any less than 0 and add results
    // step can be inverted by doing 1-step
    // step returns 0 if first < second, 1 else
    /*vec3 under = vec3(1, 1, 1) - step(vec3(xpart, ypart, zpart), vec3(0)); // if any of these are 1, the index you're calculating is oob
    vec3 over = step(vec3(xpart, ypart, zpart), cell_count.xyz); // if any of these are 1, the index you're calulating is oob
    float s = under.x + under.y + under.z + over.x + over.y + over.z; // if this is greater than 0, the index you're calculating is oob
    return s > 0 ? -1 : xpart + ypart + zpart;*/
}

void main() {
    cell_size = world_size / cell_count;

    uint i = gl_GlobalInvocationID.x;

    //if (i <= positions.length()) return; // stop if you're in the wrong place

    // that's it! so easy!
    int cell = cell_index(world_to_grid(positions[i]));
    segment_start[cell] += 1;
    segment_length[cell] += 1;
}
